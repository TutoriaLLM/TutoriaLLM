import { createValidationErrorResponseSchema } from "@/libs/errors/schemas";
import { z } from "@hono/zod-openapi";

const contentTypeEnum = [
	"user",
	"user_audio",
	"ai",
	"ai_audio",
	"log",
	"error",
	"info",
	"group_log",
	"ui", // UI elements dynamically generated by AI
	"request",
] as const;

export type ContentType = (typeof contentTypeEnum)[number];

const responseModeEnum = ["text", "audio"] as const;
// Schema for timestamp
export const timestampSchema = z.object({
	createdAt: z.string().datetime(),
	updatedAt: z.string().datetime(),
});

export type DialogueType = {
	id: number;
	contentType: ContentType;
	isUser: boolean;
	content: string | DialogueType[];
	ui?: string;
};

export const DialogueSchema: z.ZodSchema<DialogueType> = z.lazy(() =>
	z.object({
		id: z.number(),
		contentType: z.enum(contentTypeEnum),
		isUser: z.boolean(),
		content: z.union([z.string(), z.array(DialogueSchema)]),
		ui: z.string().optional(),
	}),
);
export const DialogueOpenApiSchema = DialogueSchema.openapi({
	// For lazy, you need to define it manually: https://github.com/honojs/middleware/issues/643
	type: "object",
	title: "Dialogue",
	description: "A dialogue type schema",
	example: {
		id: 1,
		contentType: "user",
		isUser: true,
		content: "Hello",
		ui: "example_ui",
	},
});

export type Dialogue = z.infer<typeof DialogueOpenApiSchema>;

export const ClickSchema = z.object({
	x: z.number(),
	y: z.number(),
	value: z.number(),
	timestamp: z.number(),
});
export type Click = z.infer<typeof ClickSchema>;

export const TutorialSchema = z.object({
	isTutorial: z.boolean(),
	tutorialId: z.number().nullable(),
	progress: z.number(),
});
export type TutorialStats = z.infer<typeof TutorialSchema>;

export const TutorialMetadataSchema = z.object({
	title: z.string(),
	description: z.string(),
	selectCount: z.number(),
	author: z.string().optional(),
});
export type TutorialMetadata = z.infer<typeof TutorialMetadataSchema>;

export const TrainingMetadataSchema = z.object({
	author: z.string().optional(),
	date: z.string().optional(),
	sessionId: z.string().optional(),
});
export type TrainingMetadata = z.infer<typeof TrainingMetadataSchema>;

export const StatsSchema = z.object({
	totalConnectingTime: z.number(),
	currentNumOfBlocks: z.number(),
	totalInvokedLLM: z.number(),
	totalUserMessages: z.number(),
	totalCodeExecutions: z.number(),
});
export type Stats = z.infer<typeof StatsSchema>;

export const AudioSchema = z.object({
	id: z.string(),
	base64: z.string(),
});
export type SavedAudio = z.infer<typeof AudioSchema>;

export const UserInfoSchema = z.object({
	id: z.string(),
	username: z.string(),
	image: z.string().nullable(),
	email: z.string(),
});

export const sessionValueSchema = z
	.object({
		// Basic Information
		uuid: z.string(),
		sessionId: z.string(),

		name: z.string().nullable(),

		// Dialogue related
		dialogue: z.array(DialogueOpenApiSchema).nullable(),

		// UI related
		quickReplies: z.array(z.string()).nullable(),
		isReplying: z.boolean(),
		workspace: z.record(z.any()).nullable(),
		isVMRunning: z.boolean(),
		clients: z.array(z.string()).nullable(),

		// Configuration related
		language: z.string().nullable(),
		easyMode: z.boolean().nullable(),
		responseMode: z.enum(responseModeEnum),
		llmContext: z.string().nullable(),

		// Statistics and progress related
		tutorial: TutorialSchema,
		stats: StatsSchema,

		// Media Relations
		audios: z.array(AudioSchema).nullable(),
		userAudio: z.string().nullable(),
		screenshot: z.string().nullable(),

		// Interaction-related
		clicks: z.array(ClickSchema).nullable(),
		userInfo: z.union([z.string(), UserInfoSchema]).nullable(),
	})
	.merge(timestampSchema);
export const listSessionValueSchema = z.array(sessionValueSchema);

export type SessionValue = z.infer<typeof sessionValueSchema>;
export type SessionValueWithoutUserInfo = Omit<SessionValue, "userInfo">;

export const keySchema = z.object({
	key: z.string().openapi({
		param: {
			name: "key",
			in: "path",
		},
	}),
});

export const languageQuerySchema = z.object({
	language: z.string(),
});

export const sessionIdSchema = z.object({
	sessionId: z.string(),
});

export const sessionNameSchema = z.object({
	sessionName: z.string(),
});

export const newSessionQuery = {
	schema: languageQuerySchema.partial().openapi("NewSessionQuery"),
	vErr: () =>
		createValidationErrorResponseSchema(newSessionQuery.schema).openapi(
			"NewSessionQueryValidationErrorResponse",
		),
};
export const putSessionRequest = {
	schema: sessionValueSchema.openapi("PutSessionRequest"),
	vErr: () =>
		createValidationErrorResponseSchema(putSessionRequest.schema).openapi(
			"PutSessionRequestValidationErrorResponse",
		),
};

export const updateSessionNameRequest = {
	schema: sessionNameSchema.openapi("UpdateSessionNameRequest"),
	vErr: () =>
		createValidationErrorResponseSchema(
			updateSessionNameRequest.schema,
		).openapi("UpdateSessionNameRequestValidationErrorResponse"),
};

// Use the same schema for put, get, and delete
export const sessionParam = {
	schema: keySchema.openapi("GetSessionParam"),
	vErr: () =>
		createValidationErrorResponseSchema(sessionParam.schema).openapi(
			"GetSessionParamValidationErrorResponse",
		),
};
